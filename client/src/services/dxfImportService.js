
// client/src/services/dxfImportService.js

/**
 * Service to parse DXF content and reconstruct packing data.
 * Compatible with DXF files generated by dxfGenerator.js
 */

export const dxfImportService = {
    /**
     * Parse DXF file content string.
     * @param {string} dxfContent 
     * @returns {Object} { container, plates, rectangles, quantities, success: boolean, error: string }
     */
    parse(dxfContent) {
        try {
            if (!dxfContent.includes('ENTITIES')) {
                throw new Error('File không đúng định dạng DXF (thiếu phần ENTITIES).');
            }

            const lines = dxfContent.split('\n').map(l => l.trim());
            const entities = this.extractEntities(lines);

            const { borders, items, labels } = this.categorizeEntities(entities);

            if (borders.length === 0) {
                throw new Error('Không tìm thấy khung viền tấm liệu (Layer BORDER).');
            }

            // 1. Reconstruct Plates from Borders
            const plates = this.reconstructPlates(borders, items, labels);

            if (plates.length === 0) {
                throw new Error('Không thể tái tạo cấu trúc tấm liệu.');
            }

            // 2. Infer Container Size from the first border
            const firstBorder = borders[0];
            const container = {
                width: Math.round(firstBorder.height),
                length: Math.round(firstBorder.width),
                layers: 1 // Default, will update from Text if found
            };

            // 3. Update container layers if text found
            // Look for text like "Sheet 1 - ... - X lop"
            // Taking the max layers found to be safe, or just from the first plate
            let maxLayers = 1;
            plates.forEach(p => {
                if (p.layerCount > maxLayers) maxLayers = p.layerCount;
            });
            container.layers = maxLayers;

            // 4. Extract Rectangles and Quantities for Input List
            const { allRectangles, quantities } = this.consolidateRectangles(plates);

            return {
                success: true,
                container,
                plates: plates.map(p => this.formatPlateForState(p)),
                rectangles: allRectangles,
                quantities
            };

        } catch (error) {
            console.error("DXF Import Error:", error);
            return { success: false, error: error.message };
        }
    },

    // Helper: Read entities
    extractEntities(lines) {
        const entities = [];
        let isSectionEntities = false;
        let currentEntity = null;
        let i = 0;

        while (i < lines.length) {
            const code = lines[i];
            const value = lines[i + 1];

            if (code === '0' && value === 'SECTION') {
                const nextCode = lines[i + 2]; // 2
                const nextVal = lines[i + 3]; // HEADER / ENTITIES
                if (nextCode === '2' && nextVal === 'ENTITIES') {
                    isSectionEntities = true;
                    i += 4;
                    continue;
                }
            }

            if (code === '0' && value === 'ENDSEC') {
                if (isSectionEntities) {
                    isSectionEntities = false;
                    break; // Stop after ENTITIES
                }
            }

            if (isSectionEntities) {
                if (code === '0') {
                    // New Entity
                    if (currentEntity) entities.push(currentEntity);
                    currentEntity = { type: value, props: {} };
                } else if (currentEntity) {
                    // Property
                    // We handle multiple values for same code (like 10, 20 coords) manually
                    // Simple key-value for unique, array for points
                    if (code === '10' || code === '20') {
                        if (!currentEntity.points) currentEntity.points = [];
                        // We need to coordinate 10 (X) and 20 (Y). 
                        // DXF usually alternates 10, 20.
                        // We'll collect raw sequence and pair them later
                        currentEntity.rawCoords = currentEntity.rawCoords || [];
                        currentEntity.rawCoords.push({ code, val: parseFloat(value) });
                    } else {
                        currentEntity.props[code] = value;
                    }
                }
            }
            i += 2;
        }
        if (currentEntity) entities.push(currentEntity);
        return entities;
    },

    categorizeEntities(entities) {
        const borders = []; // Layer BORDER
        const items = [];   // Other Layers
        const labels = [];  // TEXT entities

        entities.forEach(ent => {
            if (ent.type === 'LWPOLYLINE') {
                const layer = ent.props['8'];
                // Parse points
                const points = [];
                if (ent.rawCoords) {
                    for (let k = 0; k < ent.rawCoords.length; k += 2) {
                        const xObj = ent.rawCoords[k];
                        const yObj = ent.rawCoords[k + 1];
                        if (xObj && xObj.code === '10' && yObj && yObj.code === '20') {
                            points.push({ x: xObj.val, y: yObj.val });
                        }
                    }
                }

                // Calculate BBox
                if (points.length > 0) {
                    const xs = points.map(p => p.x);
                    const ys = points.map(p => p.y);
                    const minX = Math.min(...xs);
                    const maxX = Math.max(...xs);
                    const minY = Math.min(...ys);
                    const maxY = Math.max(...ys);

                    // Parse True Color (420) if available
                    let finalColor = '#CCCCCC';
                    const trueColorVal = ent.props['420'];
                    const aciVal = ent.props['62'] || '7';

                    if (trueColorVal) {
                        const intVal = parseInt(trueColorVal, 10);
                        // Convert 24-bit int to Hex
                        const r = (intVal >> 16) & 255;
                        const g = (intVal >> 8) & 255;
                        const b = intVal & 255;
                        const toHex = (c) => {
                            const hex = c.toString(16);
                            return hex.length === 1 ? '0' + hex : hex;
                        };
                        finalColor = `#${toHex(r)}${toHex(g)}${toHex(b)}`;
                    } else {
                        finalColor = this.aciToHex(aciVal);
                    }

                    const obj = {
                        layer,
                        points,
                        x: minX,
                        y: minY,
                        width: Math.abs(maxX - minX), // Dimension X
                        height: Math.abs(maxY - minY), // Dimension Y
                        rawColor: aciVal, // keep purely for debug
                        color: finalColor
                    };

                    if (layer === 'BORDER') {
                        borders.push(obj);
                    } else {
                        items.push(obj);
                    }
                }
            } else if (ent.type === 'TEXT') {
                const text = ent.props['1'];
                const x = parseFloat(ent.props['10']);
                const y = parseFloat(ent.props['20']);
                labels.push({ text, x, y });
            }
        });

        return { borders, items, labels };
    },

    reconstructPlates(borders, items, labels) {
        // Sort borders by X position (layout left to right)
        borders.sort((a, b) => a.x - b.x);

        return borders.map((border, index) => {
            // Find items inside this border
            // Item center should be inside border
            const containedItems = items.filter(item => {
                const cx = item.x + item.width / 2;
                const cy = item.y + item.height / 2;
                return cx >= border.x && cx <= (border.x + border.width) &&
                    cy >= border.y && cy <= (border.y + border.height);
            });

            const mappedItems = containedItems.map(item => ({
                width: item.height, // Restore original Width
                length: item.width, // Restore original Length
                x: item.y - border.y, // Restore X
                y: item.x - border.x, // Restore Y
                name: item.layer,
                color: item.color,
                rotated: false,
                id: `imported_${index}_${Math.random().toString(36).substr(2, 9)}`
            }));

            // Find label for this sheet to get Layer Count
            // Label pos: offsetX, offsetY - 20
            // Text: "Sheet ... - X lop"
            const label = labels.find(l =>
                l.x >= border.x && l.x <= (border.x + border.width) &&
                l.y < border.y && l.y >= (border.y - 100)
            );

            let layerCount = 1;
            if (label) {
                const match = label.text.match(/(\d+)\s*lop/i);
                if (match) layerCount = parseInt(match[1]);
            }

            return {
                originalIndex: index,
                layerCount,
                rectangles: mappedItems,
                label: label ? label.text : `Sheet ${index + 1}`
            };
        });
    },

    consolidateRectangles(plates) {
        const map = new Map();

        plates.forEach(plate => {
            plate.rectangles.forEach(rect => {
                // Create unique key for "Type" based on dims + name
                // Round dims to 1 decimals to avoid float issues
                const w = Number(rect.width.toFixed(1));
                const l = Number(rect.length.toFixed(1));
                // Include Color in Key so different colored items are separate types!
                const key = `${rect.name}_${w}_${l}_${rect.color}`;

                if (!map.has(key)) {
                    map.set(key, {
                        id: map.size + 1,
                        typeId: map.size + 1,
                        name: rect.name,
                        width: w,
                        length: l,
                        color: rect.color,
                        quantity: 0
                    });
                }

                const type = map.get(key);
                // Add quantity: 1 rect on plate * plate layer count
                type.quantity += (1 * plate.layerCount);

                // Assign typeId to rect for UI
                rect.typeId = type.typeId;
                rect.id = `imp_${plate.originalIndex}_${rect.id}`; // Ensure unique ID
            });
        });

        const allRectangles = Array.from(map.values());
        const quantities = {};
        allRectangles.forEach(r => quantities[r.id] = r.quantity);

        return { allRectangles, quantities };
    },

    formatPlateForState(plate) {
        return {
            originalIndex: plate.originalIndex,
            description: plate.label,
            efficiency: 0,
            layers: Array.from({ length: plate.layerCount }).map((_, i) => ({
                layerIndexInPlate: i,
                rectangles: plate.rectangles.map(r => ({ ...r, layer: i }))
            }))
        };
    },

    aciToHex(aci) {
        // Expanded fallback map based on standard AutoCAD colors
        // Standard Colors (1-9)
        const standardMap = {
            '1': '#FF0000', // Red
            '2': '#FFFF00', // Yellow
            '3': '#00FF00', // Green
            '4': '#00FFFF', // Cyan
            '5': '#0000FF', // Blue
            '6': '#FF00FF', // Magenta
            '7': '#FFFFFF', // White/Black
            '8': '#808080', // Gray
            '9': '#C0C0C0', // Light Gray
        };

        if (standardMap[aci]) return standardMap[aci];

        // Some common extensive colors often mapped
        const extraMap = {
            '10': '#FF0000', '11': '#FF7F7F', '30': '#FF7F00',
            '40': '#FFBF00', '50': '#FFFF00', '51': '#FFFF7F',
            '70': '#7FFF00', '90': '#00FF00', '91': '#7FFF7F',
            '130': '#00FFFF', '131': '#7FFFFF',
            '150': '#0000FF', '151': '#7F7FFF',
            '210': '#FF007F', '211': '#FF7FBF',
            '250': '#333333', '251': '#505050', '252': '#696969',
            '253': '#828282', '254': '#BEBEBE'
        };

        return extraMap[aci] || '#CCCCCC';
    }
};
